// Generated by CoffeeScript 1.10.0
(function() {
  suite('oauth2 login', function() {
    var dfd;
    dfd = null;
    suite('using postMessage', function() {
      var popupWindow;
      popupWindow = {
        closed: false,
        postMessage: function() {}
      };
      setup(function() {
        $window.open = function() {
          return popupWindow;
        };
        return sinon.spy($window, 'open');
      });
      suite('using config options', function() {
        return test('optional params are sent', function() {
          var expectedAuthUrl;
          expectedAuthUrl = $auth.apiUrl() + $auth.getConfig().authProviderPaths['github'] + '?auth_origin_url=' + encodeURIComponent(window.location.href) + '&spirit_animal=scorpion';
          $auth.authenticate('github', {
            params: {
              spirit_animal: 'scorpion'
            }
          });
          return assert($window.open.calledWith(expectedAuthUrl));
        });
      });
      return suite('defaults config', function() {
        setup(function() {
          dfd = $auth.authenticate('github');
          return false;
        });
        suite('postMessage success', function() {
          var expectedUser;
          expectedUser = {
            id: validUser.id,
            uid: validUser.uid,
            email: validUser.email,
            auth_token: validToken,
            expiry: validExpiry,
            client_id: validClient,
            signedIn: true,
            configName: "default"
          };
          return test('user should be authenticated, promise is resolved', function(done) {
            var called;
            called = false;
            dfd.then((function(_this) {
              return function() {
                return called = true;
              };
            })(this));
            $window.postMessage(angular.extend({
              message: 'deliverCredentials'
            }, expectedUser), '*');
            return setTimeout((function() {
              $timeout.flush();
              debugger;
              assert.deepEqual($rootScope.user, expectedUser);
              assert(true, called);
              return done();
            }));
          });
        });
        suite('directive access', function() {
          var args;
          args = 'github';
          return test('$auth.authenticate was called from $rootScope', function() {
            dfd = $rootScope.authenticate('github');
            dfd.then(function() {
              return assert(true);
            });
            return $timeout.flush();
          });
        });
        suite('postMessage error', function(done) {
          var errorResponse;
          errorResponse = {
            message: 'authFailure',
            errors: ['420']
          };
          setup(function() {
            return sinon.spy($auth, 'cancel');
          });
          return test('error response cancels authentication, rejects promise', function(done) {
            var caught;
            caught = false;
            dfd["catch"](function() {
              return caught = true;
            });
            $window.postMessage(errorResponse, '*');
            return setTimeout((function() {
              $timeout.flush();
              assert(true, caught);
              assert($auth.cancel.called);
              assert($rootScope.$broadcast.calledWith('auth:login-error'));
              return done();
            }), 0);
          });
        });
        suite('postMessage window closed before message is sent', function() {
          setup(function() {
            return sinon.spy($auth, 'cancel');
          });
          teardown(function() {
            return popupWindow.closed = false;
          });
          return test('auth is cancelled, promise is rejected', function(done) {
            var caught;
            caught = false;
            dfd["catch"]((function(_this) {
              return function() {
                return caught = true;
              };
            })(this));
            popupWindow.closed = true;
            $timeout.flush();
            assert($auth.cancel.called);
            assert.equal(true, caught);
            assert.equal(null, $auth.t);
            return done();
          });
        });
        return suite('cancel method', function() {
          test('timer is rejected then nullified', function(done) {
            var called;
            called = false;
            $auth.t["catch"]((function(_this) {
              return function() {
                return called = true;
              };
            })(this));
            $auth.cancel();
            return setTimeout((function() {
              $timeout.flush();
              assert.equal(true, called);
              assert.equal(null, $auth.t);
              return done();
            }), 0);
          });
          return test('promise is rejected then nullified', function(done) {
            var called;
            called = false;
            $auth.dfd.promise["catch"](function() {
              return called = true;
            });
            $auth.cancel();
            return setTimeout((function() {
              $timeout.flush();
              assert.equal(true, called);
              assert.equal(null, $auth.dfd);
              return done();
            }), 0);
          });
        });
      });
    });
    return suite('using hard redirect', function() {
      var successResp;
      successResp = {
        success: true,
        data: validUser
      };
      suite('to api', function() {
        var redirectUrl;
        redirectUrl = null;
        setup(function() {
          redirectUrl = $auth.buildAuthUrl('github');
          $authProvider.configure({
            forceHardRedirect: true
          });
          sinon.stub($auth, 'visitUrl').returns(null);
          $auth.authenticate('github');
          return false;
        });
        teardown(function() {
          return $authProvider.configure({
            forceHardRedirect: false
          });
        });
        return test('location should be replaced', function() {
          return assert($auth.visitUrl.calledWithMatch(redirectUrl));
        });
      });
      return suite('on return from api', function() {
        setup(function() {
          $httpBackend.expectGET('/api/auth/validate_token').respond(201, successResp);
          setValidAuthQS();
          $auth.validateUser();
          return $httpBackend.flush();
        });
        test('new user is not defined in the root scope', function() {
          return assert.equal(validUser.uid, $rootScope.user.uid);
        });
        return test('$rootScope broadcast validation success event', function() {
          return assert($rootScope.$broadcast.calledWithMatch('auth:validation-success', validUser));
        });
      });
    });
  });

}).call(this);
